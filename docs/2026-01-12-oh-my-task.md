# 任务管理系统实现规划

## 任务状态机框架图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              任务状态机 (Task State Machine)                      │
│                                  requirement_id: req-001                         │
│                                  task_id: task-main-001                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│  状态: running | paused | completed | stopped                                    │
│  当前位置: 模块[1] -> 阶段[0] -> 子任务[2]                                        │
└─────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           模块任务层 (Module Layer)                              │
│                              按依赖拓扑排序，串行执行                              │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │ 用户模块     │    │ 商品模块     │    │ 订单模块     │    │ 支付模块     │      │
│  │ mod-001     │--->│ mod-002     │--->│ mod-003     │--->│ mod-004     │      │
│  │ [completed] │    │ [running]   │    │ [pending]   │    │ [pending]   │      │
│  │ deps: []    │    │ deps: []    │    │ deps: [1,2] │    │ deps: [3]   │      │
│  └─────────────┘    └──────┬──────┘    └─────────────┘    └─────────────┘      │
│                            │                                                    │
└────────────────────────────┼────────────────────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           阶段任务层 (Phase Layer)                               │
│                              模块内部，串行执行                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│  商品模块 (mod-002)                                                              │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │ 商品管理阶段     │    │ 库存管理阶段     │    │ 搜索功能阶段     │             │
│  │ phase-001      │--->│ phase-002      │--->│ phase-003      │             │
│  │ [completed]    │    │ [running]      │    │ [pending]      │             │
│  └─────────────────┘    └────────┬────────┘    └─────────────────┘             │
│                                  │                                              │
└──────────────────────────────────┼──────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         子任务层 / 叶子层 (Leaf Task Layer)                       │
│                           阶段内部，按依赖并行执行                                  │
├─────────────────────────────────────────────────────────────────────────────────┤
│  库存管理阶段 (phase-002)                                                        │
│                                                                                 │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐    │
│  │ 库存查询      │  │ 库存扣减      │  │ 库存预警      │  │ 库存同步      │    │
│  │ leaf-001     │  │ leaf-002     │  │ leaf-003     │  │ leaf-004     │    │
│  │ [completed]  │  │ [completed]  │  │ [running]    │  │ [pending]    │    │
│  │ deps: []     │  │ deps: [001]  │  │ deps: []     │  │ deps: [002]  │    │
│  │ 2h | 15k tok │  │ 3h | 20k tok │  │ 2h | 12k tok │  │ 1h | 8k tok  │    │
│  └───────────────┘  └───────────────┘  └───────────────┘  └───────────────┘    │
│         │                  │                  │                  │             │
│         ▼                  ▼                  ▼                  ▼             │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │                        并行执行池 (Parallel Pool)                        │   │
│  │                         parallel_count = 2                              │   │
│  │  ┌─────────────────────────────┐  ┌─────────────────────────────┐      │   │
│  │  │ Subagent #1                 │  │ Subagent #2                 │      │   │
│  │  │ 执行: leaf-003 库存预警     │  │ 等待: leaf-004 库存同步     │      │   │
│  │  │ 状态: 测试中 (第2次运行)    │  │ 状态: 等待依赖 leaf-002     │      │   │
│  │  └─────────────────────────────┘  └─────────────────────────────┘      │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────┘

ID 命名规则:
  requirement_id : req-{uuid}      - 需求ID (用于暂停/继续/停止)
  task_id        : task-main-{n}   - 主任务ID
  module_id      : mod-{n}         - 模块ID
  phase_id       : phase-{n}       - 阶段ID
  leaf_id        : leaf-{n}        - 叶子任务ID

状态标识:
  [completed]  - 已完成
  [running]    - 执行中
  [pending]    - 待执行
  [paused]     - 已暂停
  [stopped]    - 已停止

执行顺序:
  1. 模块层: 按依赖拓扑排序 -> 串行执行
  2. 阶段层: 模块内部 -> 串行执行  
  3. 叶子层: 阶段内部 -> 按依赖并行执行 (parallel_count=2)
```

---

基于截图中的 "Oh-My-Task" 系统和 Factory 的 Skills + Custom Droids + MCP 架构，设计如下：

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Task Management System                    │
├─────────────────────────────────────────────────────────────┤
│  MCP Server (oh-my-task)                                    │
│  ├── TASK_HELP          - 获取命令帮助和使用示例            │
│  ├── CREATE_TASK        - 创建任务 (返回需求ID)             │
│  ├── GET_NEXT_TASK      - 获取下一个待处理任务              │
│  ├── GET_TASK_CONTEXT   - 获取任务详细上下文                │
│  ├── GET_TASK_OVERVIEW  - 查询任务编排和完成情况            │
│  ├── START_TASK         - 开始任务 (返回预估时间/token)     │
│  ├── FINISH_TASK        - 结束/强制停止任务                 │
│  ├── PAUSE_TASK         - 暂停任务 (记录状态机位置)         │
│  ├── RESUME_TASK        - 继续任务 (恢复执行)               │
│  ├── LIST_RUNNING_TASKS - 列出所有运行中的任务状态机        │
│  ├── UPDATE_TASK_STATUS - 更新任务状态                      │
│  ├── ADD_SUBTASK        - 添加子任务                        │
│  ├── UPDATE_TASK_DOC    - 更新需求/设计文档                 │
│  └── LIST_TASKS         - 列出所有任务 (含模块ID)           │
├─────────────────────────────────────────────────────────────┤
│  Custom Droid: task-coordinator                             │
│  - 统筹任务执行流程                                         │
│  - 调用 MCP 获取任务                                        │
│  - 分解复杂任务为子任务                                     │
│  - 实时更新进度                                             │
├─────────────────────────────────────────────────────────────┤
│  Skills                                                      │
│  ├── task-planning     - 任务规划与分解                     │
│  ├── task-execution    - 任务执行流程                       │
│  └── task-review       - 任务完成验证                       │
├─────────────────────────────────────────────────────────────┤
│  Skill Extension System (技能扩展系统)                       │
│  ├── IMPORT_SKILL      - 导入自定义技能                     │
│  ├── LIST_SKILLS       - 列出已安装技能                     │
│  ├── VALIDATE_SKILL    - 验证技能文档格式                   │
│  └── skill-converter   - AI 转换为规范格式                  │
└─────────────────────────────────────────────────────────────┘
```

## 实现组件

### 1. MCP Server (`oh-my-task-mcp`)
**位置**: 独立 Node.js 项目或 Python 项目
**功能**: 提供任务管理 API

```typescript
// 核心数据结构
interface Task {
  id: string;
  title: string;
  status: 'pending' | 'in_progress' | 'completed';
  parent_id?: string;
  subtasks?: Task[];
  requirement_doc?: string;
  design_doc?: string;
  issues?: string[];      // 遗留问题
  todos?: string[];       // 待完成项
  assignee?: string;
  estimated_hours?: number;
  created_at: string;
  updated_at: string;
}
```

### 2. Custom Droid (`task-coordinator.md`)
**位置**: `.factory/droids/task-coordinator.md`

```yaml
---
name: task-coordinator
description: 协调多步骤任务，实时更新进度，管理子任务分解
model: inherit
tools: ["Read", "Edit", "Execute", "mcp"]
---
```

### 3. Skills
**位置**: `.factory/skills/`

| Skill | 用途 |
|-------|------|
| `task-planning/` | 分析需求，分解为可执行子任务 |
| `task-execution/` | 执行单个任务的标准流程 |
| `task-review/` | 验证任务完成，检查遗留问题 |

## 文件结构

```
.factory/
├── droids/
│   └── task-coordinator.md
├── skills/
│   ├── task-planning/
│   │   └── SKILL.md
│   ├── task-execution/
│   │   └── SKILL.md
│   └── task-review/
│       └── SKILL.md
└── mcp.json                    # MCP 配置

oh-my-task-mcp/                 # MCP Server 项目
├── src/
│   ├── server.ts               # MCP Server 入口
│   ├── handlers/               # 工具处理器
│   └── storage/                # 任务存储 (JSON/SQLite)
├── docs/                       # 文档管理目录
│   ├── requirements/           # 需求文档
│   │   └── {task-id}-requirement.md
│   ├── development/            # 开发文档 (层级结构)
│   │   └── {module-name}/
│   │       ├── module-task.md
│   │       └── phases/
│   │           ├── phase-1.md
│   │           └── sub-phases/
│   │               └── ...
│   │   └── {module-name}/
│   │       ├── module-task.md
│   │       └── phases/
│   │           ├── phase-1.md
│   │           └── sub-phases/
│   │               └── ...
│   └── testing/                # 测试文档
│       └── {task-id}-test-plan.md
├── package.json
└── tsconfig.json
```

---

## 文档管理系统 (核心新增)

### 概述

本文档 (`2026-01-12-oh-my-task.md`) 是 **oh-my-task-mcp** 项目本身的规划文档。

当 oh-my-task-mcp 开发完成后，它将作为任务管理工具，为**其他项目**生成类似结构的文档。

```
┌─────────────────────────────────────────────────────────────┐
│                    文档模板关系                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  本文档 (oh-my-task-mcp 规划)                               │
│  C:\Users\unclefata\.factory\docs\2026-01-12-oh-my-task.md  │
│                    │                                        │
│                    │ 作为模板                               │
│                    ▼                                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  oh-my-task-mcp 为其他项目生成的文档                 │   │
│  │                                                     │   │
│  │  项目A/docs/                                        │   │
│  │  ├── requirements/xxx-requirement.md  (基于本模板)  │   │
│  │  ├── development/...                               │   │
│  │  └── testing/...                                   │   │
│  │                                                     │   │
│  │  项目B/docs/                                        │   │
│  │  ├── requirements/xxx-requirement.md  (基于本模板)  │   │
│  │  ├── development/...                               │   │
│  │  └── testing/...                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 文档目录结构 (通用模板)

以下结构适用于 oh-my-task-mcp 本身，也是后续其他项目的标准模板：

```
{project}/docs/
├── src/
│   ├── server.ts               # MCP Server 入口
│   ├── handlers/               # 工具处理器
│   └── storage/                # 任务存储 (JSON/SQLite)
├── docs/                       # 文档管理目录
│   ├── requirements/           # 需求文档
│   │   └── {task-id}-requirement.md
│   ├── development/            # 开发文档 (层级结构)
│   │   └── {module-name}/
│   │       ├── module-task.md
│   │       └── phases/
│   │           ├── phase-1.md
│   │           └── sub-phases/
│   │               └── ...
│   │   └── {module-name}/
│   │       ├── module-task.md
│   │       └── phases/
│   │           ├── phase-1.md
│   │           └── sub-phases/
│   │               └── ...
│   └── testing/                # 测试文档
│       └── {task-id}-test-plan.md
├── package.json
└── tsconfig.json
```

### 需求文档模板 (requirement.md)

后续项目通过 `CREATE_TASK` 生成的需求文档，将基于本文档的结构：

```markdown
---
task_id: req-{uuid}
title: 项目名称
created_at: 2026-01-12
status: pending_approval
task_depth: 3
---

# 项目名称

## 1. 概述
项目背景和目标描述...

## 2. 功能需求
### 2.1 模块A
- 功能点1
- 功能点2

### 2.2 模块B
- 功能点1
- 功能点2

## 3. 技术要求
- 开发规则 (参考本文档的开发规则章节)
- 技术栈选型
- 架构设计

## 4. 验收标准
- [ ] 标准1
- [ ] 标准2

## 5. 参考文档
- 本模板来源: oh-my-task-mcp 规划文档
```

### 任务层级参数 (task_depth)

创建任务时接受 `task_depth` 参数，默认值为 **3**：

| 层级 | 说明 | 文档位置 |
|------|------|----------|
| 第1层 | 功能模块 | `development/{module}/module-task.md` |
| 第2层 | 阶段任务 | `development/{module}/phases/phase-{n}.md` |
| 第3层 | 子阶段任务 | `development/{module}/phases/phase-{n}/sub-phase-{m}.md` |
| 第N层 | 递归迭代 | 继续在子文件夹中创建 |

### 阶段一：创建任务 (全自动化文档生成流程)
```
CREATE_TASK(title, description, task_depth=3)
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 生成需求文档模板                      │
│    docs/requirements/{task-id}-requirement.md │
│    【Droid 自动读取并填充需求文档内容】  │
│    状态: PENDING_APPROVAL               │
│    【填充完成后，等待用户审批】          │
└─────────────────────────────────────────┘
    │ (用户执行 APPROVE_REQUIREMENT)
    ▼
┌─────────────────────────────────────────┐
│ 2. 生成模块文档 + 阶段文档               │
│    返回 docs_to_fill 列表               │
│    【Droid 自动读取并填充每个文档内容】  │
│    状态: APPROVED                       │
└─────────────────────────────────────────┘
    │ (Droid 填充完成后执行 SET_HUMANTEST)
    ▼
┌─────────────────────────────────────────┐
│ 3. 生成叶子任务文档                      │
│    返回 leaf_docs_to_fill 列表          │
│    【Droid 自动读取并填充每个叶子文档】  │
│    状态: APPROVED (叶子任务已就绪)       │
└─────────────────────────────────────────┘
    │ 
    ▼
┌─────────────────────────────────────────┐
│ 4. 开始细化叶子任务                       │
│    - 按叶子任务逐个开发          
|    -  根据叶子的依赖，读取分配叶子任务的md |
│    - 所有文档内容已由 AI 自动填充       │
└─────────────────────────────────────────┘
    │ （用户执行 start-task后进行）
    ▼
┌─────────────────────────────────────────┐
│ 5. 开始读取每一个叶子里面的文档，进行代码生成                       │
│    - 按叶子任务逐个开发          
|    -  此时文档已经处理过了，开始生成代码 |
│    - │
└─────────────────────────────────────────┘

```

### 自动化流程说明

**APPROVE_REQUIREMENT 返回数据：**
```json
{
  "task_id": "t1",
  "docs_to_fill": [
    {"type": "module", "path": "...", "context": "模块: xxx, 需求: xxx"},
    {"type": "phase", "path": "...", "context": "模块: xxx, 阶段: xxx"}
  ],
  "next_step": "SET_HUMANTEST",
  "auto_fill": true
}
```

**SET_HUMANTEST 返回数据：**
```json
{
  "leaf_docs_to_fill": [
    {"type": "leaf", "path": "...", "context": "模块: xxx, 阶段: xxx, 叶子: xxx"}
  ],
  "next_step": "START_TASK",
  "auto_fill": true
}
```

**Droid 自动填充流程：**
1. 收到 `docs_to_fill` 列表
2. 遍历每个文档，读取内容
3. 根据 `context` 信息，用 AI 生成具体内容
4. 写入文档
5. 调用下一步命令

---

### 阶段 1.5：叶子任务生成流程 (多层级递归)

**核心逻辑：阶段文档完成后才生成叶子任务，叶子任务可递归细分**

```
阶段文档编辑完成
    │ (Hook 自动触发 或 用户执行 COMPLETE_PHASE)
    ▼
┌─────────────────────────────────────────┐
│ 1. 读取阶段文档配置                      │
│    - manual_test: false (默认)          │
│    - 其他配置项...                       │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. 生成叶子任务                          │
│    根据 task_depth 决定是否可执行:       │
│    - depth >= 3: is_executable = true   │
│    - depth < 3: is_executable = false   │
│      (需要继续细分)                      │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 3. 创建叶子任务文档                      │
│    docs/development/{module}/phases/    │
│    {phase-id}/{leaf-id}.md              │
└─────────────────────────────────────────┘
    │ (如果 is_executable = false)
    ▼
┌─────────────────────────────────────────┐
│ 4. 叶子文档编辑完成后                    │
│    (Hook 自动触发 或 COMPLETE_LEAF)      │
│    递归生成子叶子任务                    │
│    直到 is_executable = true            │
└─────────────────────────────────────────┘
```

### 叶子任务类型定义

```typescript
interface LeafTask {
  id: string;
  name: string;
  description: string;
  status: TaskStatus;
  phase_id: string;
  parent_id?: string;           // 父叶子任务ID（支持多层级）
  dependencies: string[];
  children?: LeafTask[];        // 子叶子任务（多层级细分）
  is_executable: boolean;       // 是否为可执行的最终叶子
  doc_path?: string;            // 叶子任务文档路径
}
```

### 阶段文档配置选项

```yaml
---
phase_id: phase-mod-t1-1-1
module: 核心模块
manual_test: false              # 设为 true 启用人工测试环节
---
```

### 开发阶段：只执行最终叶子任务

**重要：中间层叶子只是过渡，只有 `is_executable=true` 的叶子才是实际开发步骤**

```
GET_EXECUTABLE_TASKS(requirement_id)
    │
    ▼
┌─────────────────────────────────────────┐
│ 遍历所有叶子任务树                       │
│ 收集 is_executable=true 的叶子          │
│ 返回可执行任务列表                       │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 按依赖顺序执行可执行叶子                 │
│ 读取叶子文档 → 编写代码 → 测试          │
└─────────────────────────────────────────┘
```

---

### 阶段二：执行任务 (开发流程)

```
EXECUTE_TASK(task_id, parallel_count=2)
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 遍历 development/ 获取所有模块        │
│    解析每个 module-task.md 的依赖        │
│    构建模块级依赖图 (DAG)                │
│    按依赖关系排序模块执行顺序            │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. 按排序后顺序串行处理每个模块          │
│    (有依赖的模块等待依赖完成后执行)      │
│    进入模块文件夹，递归到下一层级        │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 3. 到达最底层文件夹 (叶子层)             │
│    读取该层的 phase-task.md             │
│    解析 dependencies 字段               │
│    构建叶子任务依赖图 (DAG)              │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 4. 并行执行最底层叶子文档                │
│    - 无依赖叶子: 可并行执行              │
│    - 有依赖叶子: 等待依赖完成后执行      │
│    - 默认并行数: parallel_count=2        │
│    - 每个叶子由独立 Subagent 执行        │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 5. 当前层所有叶子完成后                  │
│    生成测试文档，运行测试 (两次)         │
│    逻辑审查，通过门禁后返回上层          │
└─────────────────────────────────────────┘
```

### 模块任务文档格式 (module-task.md)

```markdown
---
name: 用户模块
dependencies: []              # 无依赖，优先执行
priority: 1
estimated_hours: 16
---

# 模块描述
...
```

```markdown
---
name: 订单模块
dependencies: ["用户模块", "商品模块"]  # 有依赖，等待完成后执行
priority: 2
estimated_hours: 24
---

# 模块描述
...
```

### 文件夹层级结构示例

**核心原则：叶子节点在 phases 目录下递归划分，不独立出来**

```
development/{task-id}/
├── 用户模块/                              # 模块层
│   ├── module-task.md                     # 模块文档 (AI 填充)
│   └── phases/                            # 阶段目录
│       ├── 认证阶段/                      # 阶段层
│       │   ├── phase-task.md              # 阶段文档 (AI 填充)
│       │   ├── 登录功能/                  # 叶子层1 (从阶段文档划分)
│       │   │   ├── leaf-task.md           # 叶子文档 (AI 填充)
│       │   │   ├── 表单验证/              # 叶子层2 (从叶子文档继续划分)
│       │   │   │   └── leaf-task.md       # 可执行叶子
│       │   │   └── API调用/
│       │   │       └── leaf-task.md       # 可执行叶子
│       │   ├── 注册功能/
│       │   │   └── leaf-task.md           # 可执行叶子 (无需继续划分)
│       │   └── 密码重置/
│       │       └── leaf-task.md
│       └── 权限阶段/
│           ├── phase-task.md
│           ├── 角色管理/
│           │   └── leaf-task.md
│           └── 权限检查/
│               └── leaf-task.md
└── 订单模块/
    ├── module-task.md
    └── phases/
        └── ...
```

### 叶子任务划分流程

```
读取模块文档 (module-task.md)
    │
    ▼
生成阶段目录和阶段文档 (phase-task.md)
    │
    ▼
读取阶段文档，AI 划分叶子任务
    │
    ▼
在 phases/{阶段名}/ 下创建叶子目录
    │
    ▼
如果 task_depth 未达到，继续递归划分
    │
    ▼
直到 is_executable = true (可执行叶子)
```

### 最底层任务文档格式 (叶子文档)

**任务划分原则：原子性 + 独立性**

| 原则 | 说明 | 示例 |
|------|------|------|
| **原子性** | 任务不可再分，完成即交付 | ✅ "实现登录API" ❌ "实现用户系统" |
| **独立性** | 任务可独立执行和测试 | ✅ "密码加密工具函数" ❌ "登录流程第2步" |
| **单一职责** | 一个任务只做一件事 | ✅ "JWT生成" ❌ "JWT生成+验证+刷新" |
| **可验证** | 有明确的完成标准 | ✅ "返回200且包含token" |
| **时间可控** | 预估时间 1-4 小时 | 超过4小时应继续拆分 |

**依赖声明规则：**
- 只声明**直接依赖**，不声明传递依赖
- 依赖项必须是**同一层级**的其他叶子任务
- 尽量减少依赖，保持任务独立性

```markdown
---
name: 登录功能
dependencies: []              # 无依赖，可与其他叶子并行
priority: 1
estimated_hours: 2            # 原子任务，2小时内完成
atomic: true                  # 标记为原子任务
testable: true                # 可独立测试
---

# 任务描述
实现用户登录 API 接口

# 输入
- username: string
- password: string

# 输出
- token: JWT string
- expires_in: number

# 验收标准
1. POST /api/login 返回 200 + token
2. 错误密码返回 401
3. 单元测试覆盖率 > 80%

# 不包含 (边界声明)
- 不包含注册逻辑
- 不包含密码重置
- 不包含 token 刷新
```

```markdown
---
name: 权限检查中间件
dependencies: ["登录功能"]    # 只依赖登录，不依赖角色管理
priority: 2
estimated_hours: 2
atomic: true
testable: true
---

# 任务描述
实现 Express 权限检查中间件

# 输入
- req.headers.authorization: Bearer token

# 输出
- req.user: { id, roles }
- 或 403 Forbidden

# 验收标准
1. 有效 token 通过，注入 user
2. 无效 token 返回 401
3. 权限不足返回 403

# 不包含 (边界声明)
- 不包含角色定义
- 不包含权限配置
```

### 并行调度算法 (模块依赖排序 + 最底层叶子并行)

```python
def execute_task(task_id, parallel_count=2):
    """主入口：模块按依赖排序串行，最底层叶子并行执行"""
    root_path = f"docs/development/{task_id}/"
    
    # 1. 获取所有模块并解析依赖
    modules = list_folders(root_path)
    module_graph = {}
    
    for module in modules:
        module_doc = read_file(f"{module.path}/module-task.md")
        metadata = parse_yaml_frontmatter(module_doc)
        module_graph[metadata["name"]] = {
            "path": module.path,
            "dependencies": metadata.get("dependencies", []),
            "priority": metadata.get("priority", 99),
            "status": "pending"
        }
    
    # 2. 拓扑排序模块 (按依赖关系)
    sorted_modules = topological_sort_modules(module_graph)
    
    # 3. 按排序后顺序串行处理每个模块
    for module_name in sorted_modules:
        module_info = module_graph[module_name]
        
        # 等待依赖模块完成
        wait_for_dependencies(module_info["dependencies"], module_graph)
        
        # 更新状态
        module_graph[module_name]["status"] = "in_progress"
        
        # 递归处理模块
        process_module(module_info["path"], parallel_count)
        
        # 标记完成
        module_graph[module_name]["status"] = "completed"

def topological_sort_modules(module_graph):
    """拓扑排序：确保依赖模块先执行"""
    in_degree = {name: 0 for name in module_graph}
    
    # 计算入度
    for name, info in module_graph.items():
        for dep in info["dependencies"]:
            if dep in in_degree:
                in_degree[name] += 1
    
    # BFS 拓扑排序
    queue = [name for name, degree in in_degree.items() if degree == 0]
    queue.sort(key=lambda x: module_graph[x]["priority"])  # 同级按优先级排序
    
    sorted_list = []
    while queue:
        current = queue.pop(0)
        sorted_list.append(current)
        
        for name, info in module_graph.items():
            if current in info["dependencies"]:
                in_degree[name] -= 1
                if in_degree[name] == 0:
                    queue.append(name)
                    queue.sort(key=lambda x: module_graph[x]["priority"])
    
    return sorted_list

def process_module(module_path, parallel_count):
    """递归处理模块，直到最底层"""
    sub_folders = list_folders(module_path)
    
    if is_leaf_layer(sub_folders):
        # 到达最底层，并行执行叶子文档
        execute_leaf_tasks_parallel(module_path, parallel_count)
    else:
        # 还有子层级，串行递归处理
        for sub_folder in sub_folders:
            process_module(sub_folder.path, parallel_count)
```

def execute_leaf_tasks_parallel(leaf_folder_path, parallel_count):
    """并行执行最底层的叶子文档"""
    # 1. 获取所有叶子文档
    leaf_docs = list_md_files(leaf_folder_path)
    
    # 2. 解析依赖关系，构建 DAG
    dependency_graph = {}
    for doc in leaf_docs:
        metadata = parse_yaml_frontmatter(read_file(doc))
        dependency_graph[metadata["name"]] = {
            "path": doc,
            "dependencies": metadata.get("dependencies", []),
            "status": "pending"
        }
    
    # 3. 拓扑排序 + 并行调度
    running_tasks = []
    completed = set()
    
    while len(completed) < len(leaf_docs):
        # 找出可执行的叶子 (依赖已完成)
        ready_leaves = [
            name for name, info in dependency_graph.items()
            if name not in completed
            and all(dep in completed for dep in info["dependencies"])
            and name not in [t.name for t in running_tasks]
        ]
        
        # 启动新任务 (不超过 parallel_count)
        while len(running_tasks) < parallel_count and ready_leaves:
            leaf_name = ready_leaves.pop(0)
            leaf_info = dependency_graph[leaf_name]
            task = launch_subagent(leaf_name, leaf_info["path"])
            running_tasks.append(task)
        
        # 等待任意任务完成
        finished = wait_any(running_tasks)
        completed.add(finished.name)
        running_tasks.remove(finished)
    
    # 4. 所有叶子完成后，生成测试文档并运行门禁
    generate_test_doc(leaf_folder_path)
    run_tests_and_check_gate(leaf_folder_path)

def launch_subagent(task_name, doc_path):
    """启动独立 Subagent 执行单个叶子任务"""
    # 读取任务文档
    task_doc = read_file(doc_path)
    
    # 执行任务
    execute_task_from_doc(task_doc)
    
    # 更新状态
    update_task_status(task_name, "completed")
```

### 测试文档生成时机

**重要**: 测试文档在**开发阶段**生成，而非创建任务时

```
模块开发完成
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 生成测试文档                          │
│    基于 oh-my-task-templates.md 模板     │
│    docs/testing/{task-id}/{module}/     │
│    根据验收标准生成测试用例              │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. 第一次测试运行                        │
│    - 执行所有测试用例                    │
│    - 记录结果到测试文档                  │
│    - 记录失败详情和错误信息              │
└─────────────────────────────────────────┘
    │
    ▼ (如有失败)
┌─────────────────────────────────────────┐
│ 3. 问题修复                              │
│    - 分析失败原因                        │
│    - 修复代码问题                        │
│    - 更新测试文档的问题记录              │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 4. 第二次测试运行                        │
│    - 再次执行所有测试用例                │
│    - 更新测试文档运行记录                │
│    - 确认问题已修复                      │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 5. 逻辑审查                              │
│    - 重新读取测试文档                    │
│    - 检查测试覆盖完整性                  │
│    - 检查是否有逻辑问题                  │
│    - 验证测试用例与验收标准对应          │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 6. 门禁判定                              │
│    ✅ 两次测试通过 + 逻辑审查通过        │
│       → 模块完成，进入下一阶段           │
│    ❌ 测试失败或逻辑问题                 │
│       → 返回步骤3继续修复                │
└─────────────────────────────────────────┘
```

### 测试流程伪代码

```python
def run_test_phase(task, test_doc_path):
    """执行测试阶段：两次测试 + 逻辑审查"""
    
    # 1. 生成测试文档
    test_doc = generate_test_doc_from_template(
        task=task,
        template_path="docs/oh-my-task-templates.md"
    )
    write_file(test_doc_path, test_doc)
    
    max_attempts = 3  # 最大修复尝试次数
    attempt = 0
    
    while attempt < max_attempts:
        attempt += 1
        
        # 2. 第一次测试运行
        run1_result = execute_tests(task)
        update_test_doc_run_record(test_doc_path, run_number=1, result=run1_result)
        
        if run1_result.failed:
            # 3. 问题修复
            fix_issues(run1_result.failures)
            update_test_doc_issue_record(test_doc_path, run1_result.failures)
        
        # 4. 第二次测试运行
        run2_result = execute_tests(task)
        update_test_doc_run_record(test_doc_path, run_number=2, result=run2_result)
        
        if run2_result.all_passed:
            # 5. 逻辑审查
            review_result = logic_review(test_doc_path, task)
            
            if review_result.passed:
                # 6. 门禁通过
                update_gate_status(task, "passed")
                return GateResult(passed=True)
            else:
                # 逻辑问题，需要修复
                log(f"逻辑审查发现问题: {review_result.issues}")
                fix_logic_issues(review_result.issues)
        else:
            # 第二次测试仍失败，继续修复循环
            log(f"第二次测试失败，尝试 {attempt}/{max_attempts}")
    
    # 超过最大尝试次数
    update_gate_status(task, "failed")
    return GateResult(passed=False, reason="超过最大修复尝试次数")

def logic_review(test_doc_path, task):
    """逻辑审查：检查测试文档完整性和正确性"""
    test_doc = read_file(test_doc_path)
    
    issues = []
    
    # 检查清单
    checks = [
        ("测试用例覆盖所有验收标准", check_acceptance_coverage),
        ("边界条件已测试", check_boundary_tests),
        ("错误处理已测试", check_error_handling),
        ("无重复测试用例", check_no_duplicates),
        ("测试独立性", check_test_independence),
    ]
    
    for check_name, check_func in checks:
        result = check_func(test_doc, task)
        if not result.passed:
            issues.append({
                "check": check_name,
                "issue": result.issue,
                "suggestion": result.suggestion
            })
    
    # 更新测试文档的审查结论
    update_test_doc_review(test_doc_path, issues)
    
    return ReviewResult(
        passed=len(issues) == 0,
        issues=issues
    )
```

### 测试文档更新示例

测试运行后，测试文档会自动更新：

```markdown
## 3. 测试运行记录

### 第 1 次运行

> 状态: ❌ 失败
> 时间: 2026-01-12T11:15:00Z
> 耗时: 1.2s

**结果统计:** 总测试: 6 | 通过: 4 | 失败: 2

**失败详情:**
- UT-002: should return 401 for invalid password
  - Expected: 401, Received: 500
- UT-003: should return 404 for non-existent user
  - Expected: 404, Received: 500

---

### 第 2 次运行

> 状态: ✅ 通过
> 时间: 2026-01-12T11:25:00Z
> 耗时: 1.1s

**结果统计:** 总测试: 6 | 通过: 6 | 失败: 0

---

## 4. 问题与修复记录

| 运行次数 | 问题描述 | 修复方案 | 修复状态 |
|---------|---------|---------|---------|
| 1 | 错误处理返回500而非具体状态码 | 添加错误类型判断，返回对应状态码 | ✅ 已修复 |

---

## 5. 逻辑审查

### 5.1 审查清单

- [x] 测试用例覆盖所有验收标准
- [x] 边界条件已测试
- [x] 错误处理已测试
- [x] 无重复测试用例
- [x] 测试独立性 (无相互依赖)

### 5.2 审查结论

> ✅ 审查通过，无逻辑问题

---

## 6. 最终结论

| 项目 | 结果 |
|------|------|
| 测试通过 | ✅ 是 (第2次运行) |
| 覆盖率 | 85.2% |
| 门禁状态 | ✅ 通过 |
```

### 层级生成算法 (伪代码)

```python
def generate_dev_docs(requirement_doc, task_depth, current_depth=1, parent_path="development"):
    if current_depth > task_depth:
        return
    
    if current_depth == 1:
        # 第1层: 按功能模块拆分
        modules = analyze_requirement_to_modules(requirement_doc)
        for module in modules:
            module_path = f"{parent_path}/{module.name}"
            create_folder(module_path)
            create_file(f"{module_path}/module-task.md", module.content)
            
            if task_depth > 1:
                generate_dev_docs(module.content, task_depth, 2, module_path)
    
    elif current_depth == 2:
        # 第2层: 按阶段拆分
        phases_path = f"{parent_path}/phases"
        create_folder(phases_path)
        phases = split_to_phases(read_file(f"{parent_path}/module-task.md"))
        for i, phase in enumerate(phases):
            create_file(f"{phases_path}/phase-{i+1}.md", phase.content)
            
            if task_depth > 2:
                generate_dev_docs(phase.content, task_depth, 3, f"{phases_path}/phase-{i+1}")
    
    else:
        # 第N层: 递归迭代子阶段
        sub_phases_path = f"{parent_path}"
        create_folder(sub_phases_path)
        parent_doc = find_parent_phase_doc(parent_path)
        sub_phases = split_to_sub_phases(read_file(parent_doc))
        for i, sub_phase in enumerate(sub_phases):
            create_file(f"{sub_phases_path}/sub-phase-{i+1}.md", sub_phase.content)
            
            if current_depth < task_depth:
                generate_dev_docs(sub_phase.content, task_depth, current_depth+1, 
                                  f"{sub_phases_path}/sub-phase-{i+1}")
```

---

## 测试驱动开发门禁系统 (TDD Gate)

### 核心原则

**只有当前阶段的所有测试任务完成，才能进入下一阶段**

### 任务状态机

```
                    ┌──────────────┐
                    │   CREATED    │
                    └──────┬───────┘
                           │ 生成需求文档
                           ▼
                    ┌──────────────┐
                    │PENDING_APPROVAL│ ← 用户确认需求
                    └──────┬───────┘
                           │ 用户批准
                           ▼
                    ┌──────────────┐
                    │  PLANNING    │ ← 生成开发/测试文档
                    └──────┬───────┘
                           │
                           ▼
              ┌────────────────────────┐
              │      DEVELOPMENT       │
              │  ┌──────────────────┐  │
              │  │ Phase 1          │  │
              │  │ ├─ Dev Tasks     │  │
              │  │ └─ Test Tasks ◄──┼──┼── 必须全部通过
              │  └────────┬─────────┘  │
              │           │ 门禁检查    │
              │           ▼            │
              │  ┌──────────────────┐  │
              │  │ Phase 2          │  │
              │  │ ├─ Dev Tasks     │  │
              │  │ └─ Test Tasks ◄──┼──┼── 必须全部通过
              │  └────────┬─────────┘  │
              │           │            │
              │          ...           │
              └────────────┬───────────┘
                           │ 所有阶段完成
                           ▼
                    ┌──────────────┐
                    │  COMPLETED   │
                    └──────────────┘
```

### 门禁检查 MCP 工具

```typescript
// 新增 MCP 工具
interface MCPTools {
  // ... 原有工具 ...
  
  // 门禁检查
  CHECK_PHASE_GATE: {
    input: { task_id: string, phase_id: string },
    output: { 
      can_proceed: boolean,
      blocking_tests: TestTask[],
      passed_tests: TestTask[],
      message: string
    }
  },
  
  // 创建任务 (带层级参数)
  CREATE_TASK: {
    input: {
      title: string,
      description: string,
      task_depth?: number  // 默认 3
    },
    output: {
      task_id: string,
      requirement_doc_path: string,
      status: 'PENDING_APPROVAL'
    }
  },
  
  // 确认需求文档
  APPROVE_REQUIREMENT: {
    input: { task_id: string },
    output: {
      status: 'PLANNING',
      dev_docs_generated: string[],
      test_docs_generated: string[]
    }
  }
}
```

### 测试任务结构

```typescript
interface TestTask {
  id: string;
  name: string;
  type: 'unit' | 'integration' | 'e2e' | 'manual';
  status: 'pending' | 'running' | 'passed' | 'failed';
  phase_id: string;
  dev_task_id: string;  // 关联的开发任务
  test_file?: string;
  last_run?: string;
  error_message?: string;
}

interface Phase {
  id: string;
  name: string;
  dev_tasks: DevTask[];
  test_tasks: TestTask[];
  gate_status: 'locked' | 'unlocked';  // 门禁状态
}
```

## 实现步骤

1. **创建 MCP Server** (oh-my-task-mcp)
   - 实现 stdio 类型 MCP 服务
   - 支持任务 CRUD 操作
   - 本地 JSON 文件存储

2. **创建 Custom Droid** (task-coordinator)
   - 编写系统提示词
   - 配置工具权限
   - 定义任务协调流程

3. **创建 Skills**
   - task-planning: 任务分解逻辑
   - task-execution: 执行标准流程
   - task-review: 完成验证清单

4. **配置 MCP** (.factory/mcp.json)
   - 注册 oh-my-task MCP server

## 工作流示例

```
用户: "开始挂机系统测试调试任务"
    ↓
Droid 调用 task-coordinator
    ↓
MCP: GET_NEXT_TASK → 返回 "2.6 挂机系统测试调试"
    ↓
MCP: GET_TASK_CONTEXT → 返回任务详情、子任务、遗留问题
    ↓
Skill: task-planning → 分析当前进度，确定下一步
    ↓
Skill: task-execution → 执行具体开发/调试工作
    ↓
MCP: UPDATE_TASK_STATUS → 更新进度
    ↓
Skill: task-review → 验证完成，记录遗留问题
```

## 技术选型建议

| 组件 | 推荐方案 |
|------|----------|
| MCP Server | TypeScript + @modelcontextprotocol/sdk |
| HTTP API | Express.js (REST API) |
| 数据存储 | JSON 文件 (简单) 或 SQLite (复杂) |
| 任务 ID | UUID v4 |
| 配置格式 | YAML frontmatter + Markdown |

---

## 开发规则

### 1. 文档驱动开发 (Document-Driven Development)

- 所有功能开发前必须先更新设计文档
- 代码变更后同步更新相关文档
- 文档与代码保持实时一致

### 2. 严格面向对象 (Strict OOP)

```typescript
/**
 * 任务状态机类
 * 
 * @description 管理单个需求的完整生命周期
 * @related TaskModule - 模块任务管理
 * @related TaskPhase - 阶段任务管理
 * @related LeafTask - 叶子任务执行
 * @related TaskStateStore - 状态持久化
 */
class TaskStateMachine {
  private readonly requirementId: string;
  private readonly modules: TaskModule[];
  private state: TaskState;
  
  // 方法实现...
}
```

### 3. MVC 架构 (低耦合)

```
src/
├── models/              # 数据模型层 (M)
│   ├── Task.ts
│   ├── Module.ts
│   ├── Phase.ts
│   └── LeafTask.ts
├── views/               # 视图层 (V) - API 响应格式化
│   ├── TaskView.ts
│   ├── TreeView.ts
│   └── StatusView.ts
├── controllers/         # 控制器层 (C) - 业务逻辑
│   ├── TaskController.ts
│   ├── StateController.ts
│   └── ExecutionController.ts
├── services/            # 服务层 - 核心逻辑
│   ├── TaskService.ts
│   ├── SchedulerService.ts
│   └── BackupService.ts
└── routes/              # 路由层 - API 入口
    └── api.ts
```

### 4. 注释规范

```typescript
/**
 * 任务调度服务
 * 
 * @description 负责任务的调度和并行执行管理
 * @related TaskStateMachine - 状态机管理
 * @related LeafTask - 叶子任务
 * @related SubagentPool - 子代理池
 * 
 * @example
 * const scheduler = new SchedulerService(parallelCount: 2);
 * scheduler.schedulePhase(phase);
 */
class SchedulerService {
  /**
   * 调度阶段内的叶子任务
   * @param phase - 待调度的阶段
   * @returns 调度结果，包含已分配的任务列表
   */
  schedulePhase(phase: TaskPhase): ScheduleResult {
    // 实现...
  }
}
```

### 5. 防御编程规范

```typescript
// 最小化防御编程，必须输出错误信息
class TaskService {
  getTask(taskId: string): Task | null {
    const task = this.store.find(taskId);
    
    if (!task) {
      // 必须输出错误信息
      console.error(`[TaskService.getTask] Task not found: ${taskId}`);
      return null;
    }
    
    return task;
  }
  
  // 关键操作使用断言
  executeTask(taskId: string): ExecutionResult {
    const task = this.getTask(taskId);
    
    if (!task) {
      // 返回明确的错误结果
      return {
        success: false,
        error: `Task not found: ${taskId}`,
        errorCode: 'TASK_NOT_FOUND'
      };
    }
    
    // 正常执行...
  }
}
```

---

## REST API 文档

### 基础信息

| 项目 | 值 |
|------|-----|
| Base URL | `http://localhost:3456/api/v1` |
| 数据格式 | JSON |
| 认证方式 | 无 (本地服务) |
| 端口配置 | 环境变量 `OH_MY_TASK_PORT` (默认 3456) |

REST API 服务器随 MCP 服务器自动启动。

---

### API 1: 获取任务树结构

**GET** `/tasks/:id/tree`

获取指定任务的完整树结构，包含模块、阶段、叶子任务。

**请求参数:**
- `id` (path): 任务ID (如 `req-abc123`)

**响应示例:**

```json
{
  "success": true,
  "data": {
    "id": "req-abc123",
    "title": "电商系统开发",
    "status": "running",
    "progress": {
      "total_modules": 4,
      "completed_modules": 1,
      "percent": 35
    },
    "modules": [
      {
        "id": "mod-001",
        "name": "用户模块",
        "status": "completed",
        "phases": [
          {
            "id": "phase-001",
            "name": "设计阶段",
            "status": "completed",
            "tasks": [
              { "id": "task-001", "name": "数据库设计", "status": "completed" },
              { "id": "task-002", "name": "API设计", "status": "completed" }
            ]
          }
        ]
      },
      {
        "id": "mod-002",
        "name": "商品模块",
        "status": "running",
        "phases": []
      }
    ]
  }
}
```

---

### API 2: 读取文档内容

**GET** `/docs?path=xxx`

读取 docs 目录下的 Markdown 文档内容。

**请求参数:**
- `path` (query): 相对于 docs 目录的文档路径

**请求示例:**
```
GET /api/v1/docs?path=requirements/req-abc123-requirement.md
```

**响应示例:**

```json
{
  "success": true,
  "data": {
    "path": "requirements/req-abc123-requirement.md",
    "content": "---\ntask_id: req-abc123\ntitle: 电商系统开发\n...",
    "size": 2048
  }
}
```

**错误响应:**
```json
{
  "success": false,
  "error": "文档不存在"
}
```

---

### API 3: 获取任务列表

**GET** `/tasks`

获取所有任务列表，可按状态筛选。

**请求参数:**
- `status` (query, 可选): 按状态筛选 (`pending_approval`, `approved`, `running`, `paused`, `completed`, `force_stopped`)

**请求示例:**
```
GET /api/v1/tasks
GET /api/v1/tasks?status=running
```

**响应示例:**

```json
{
  "success": true,
  "data": [
    {
      "id": "req-abc123",
      "title": "电商系统开发",
      "status": "running",
      "created_at": "2026-01-12T09:00:00Z"
    },
    {
      "id": "req-def456",
      "title": "支付系统重构",
      "status": "paused",
      "created_at": "2026-01-12T08:00:00Z"
    }
  ]
}
```

---

### API 4: 获取运行中任务状态机列表

**GET** `/tasks/running`

获取当前所有运行中和暂停的任务状态机列表。

**请求参数:** 无

**响应示例:**

```json
{
  "success": true,
  "data": {
    "tasks": [
      {
        "requirement_id": "req-001",
        "task_id": "task-main-001",
        "task_name": "电商系统开发",
        "status": "running",
        "progress": {
          "total_modules": 4,
          "completed_modules": 1,
          "current_module": "mod-002",
          "current_module_name": "商品模块",
          "percent": 35
        },
        "started_at": "2026-01-12T09:00:00Z",
        "last_updated": "2026-01-12T11:30:00Z"
      },
      {
        "requirement_id": "req-002",
        "task_id": "task-main-002",
        "task_name": "支付系统重构",
        "status": "paused",
        "progress": {
          "total_modules": 2,
          "completed_modules": 0,
          "current_module": "mod-001",
          "current_module_name": "支付网关",
          "percent": 15
        },
        "started_at": "2026-01-12T08:00:00Z",
        "last_updated": "2026-01-12T10:00:00Z",
        "paused_at": "2026-01-12T10:00:00Z"
      }
    ],
    "summary": {
      "total_running": 1,
      "total_paused": 1,
      "total": 2
    }
  },
  "timestamp": "2026-01-12T12:00:00Z"
}
```

---

### API 2: 获取任务执行情况

**GET** `/tasks/:requirement_id/execution`

获取指定任务状态机的详细执行情况。

**路径参数:**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| requirement_id | string | 是 | 需求ID |

**响应示例:**

```json
{
  "success": true,
  "data": {
    "requirement_id": "req-001",
    "task_id": "task-main-001",
    "task_name": "电商系统开发",
    "status": "running",
    "execution_state": {
      "current_position": {
        "module_index": 1,
        "module_id": "mod-002",
        "module_name": "商品模块",
        "phase_index": 1,
        "phase_id": "phase-002",
        "phase_name": "库存管理阶段",
        "leaf_tasks_running": ["leaf-003"],
        "leaf_tasks_pending": ["leaf-004"]
      },
      "parallel_pool": {
        "max_count": 2,
        "active_count": 1,
        "agents": [
          {
            "agent_id": "subagent-1",
            "task_id": "leaf-003",
            "task_name": "库存预警",
            "status": "testing",
            "test_run": 2,
            "started_at": "2026-01-12T11:00:00Z"
          },
          {
            "agent_id": "subagent-2",
            "task_id": null,
            "status": "idle",
            "waiting_for": "leaf-002 completion"
          }
        ]
      }
    },
    "progress": {
      "modules": {
        "total": 4,
        "completed": 1,
        "in_progress": 1,
        "pending": 2
      },
      "phases": {
        "total": 9,
        "completed": 4,
        "in_progress": 1,
        "pending": 4
      },
      "leaf_tasks": {
        "total": 24,
        "completed": 10,
        "in_progress": 1,
        "pending": 13
      },
      "overall_percent": 42
    },
    "time_stats": {
      "started_at": "2026-01-12T09:00:00Z",
      "elapsed_time": "3h 0m",
      "estimated_remaining": "4h 15m",
      "estimated_completion": "2026-01-12T16:15:00Z"
    },
    "token_stats": {
      "total_estimated": 180000,
      "used": 75000,
      "remaining": 105000
    }
  },
  "timestamp": "2026-01-12T12:00:00Z"
}
```

---

### API 3: 获取任务树结构

**GET** `/tasks/:requirement_id/tree`

获取任务状态机的完整树结构，包含所有层级和流程信息。

**路径参数:**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| requirement_id | string | 是 | 需求ID |

**查询参数:**

| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| depth | number | 否 | all | 返回层级深度 (1=模块, 2=阶段, 3=叶子) |
| include_completed | boolean | 否 | true | 是否包含已完成任务 |

**响应示例:**

```json
{
  "success": true,
  "data": {
    "requirement_id": "req-001",
    "task_id": "task-main-001",
    "task_name": "电商系统开发",
    "status": "running",
    "tree": {
      "modules": [
        {
          "module_id": "mod-001",
          "module_name": "用户模块",
          "status": "completed",
          "dependencies": [],
          "execution_order": 1,
          "phases": [
            {
              "phase_id": "phase-001",
              "phase_name": "认证阶段",
              "status": "completed",
              "execution_order": 1,
              "leaf_tasks": [
                {
                  "leaf_id": "leaf-001",
                  "task_name": "登录功能",
                  "status": "completed",
                  "dependencies": [],
                  "estimated_time": "2h",
                  "actual_time": "1h 45m",
                  "estimated_tokens": 15000,
                  "actual_tokens": 12500,
                  "test_results": {
                    "run_count": 2,
                    "final_status": "passed",
                    "logic_review": "approved"
                  }
                },
                {
                  "leaf_id": "leaf-002",
                  "task_name": "注册功能",
                  "status": "completed",
                  "dependencies": ["leaf-001"],
                  "estimated_time": "2h",
                  "actual_time": "2h 10m",
                  "estimated_tokens": 18000,
                  "actual_tokens": 19200,
                  "test_results": {
                    "run_count": 2,
                    "final_status": "passed",
                    "logic_review": "approved"
                  }
                }
              ]
            }
          ]
        },
        {
          "module_id": "mod-002",
          "module_name": "商品模块",
          "status": "running",
          "dependencies": [],
          "execution_order": 2,
          "phases": [
            {
              "phase_id": "phase-002",
              "phase_name": "商品管理阶段",
              "status": "completed",
              "execution_order": 1,
              "leaf_tasks": [...]
            },
            {
              "phase_id": "phase-003",
              "phase_name": "库存管理阶段",
              "status": "running",
              "execution_order": 2,
              "leaf_tasks": [
                {
                  "leaf_id": "leaf-003",
                  "task_name": "库存预警",
                  "status": "running",
                  "dependencies": [],
                  "estimated_time": "2h",
                  "elapsed_time": "1h 30m",
                  "estimated_tokens": 12000,
                  "used_tokens": 8500,
                  "current_phase": "testing_run_2"
                },
                {
                  "leaf_id": "leaf-004",
                  "task_name": "库存同步",
                  "status": "pending",
                  "dependencies": ["leaf-002"],
                  "blocked_by": "leaf-002",
                  "estimated_time": "1h",
                  "estimated_tokens": 8000
                }
              ]
            }
          ]
        },
        {
          "module_id": "mod-003",
          "module_name": "订单模块",
          "status": "pending",
          "dependencies": ["mod-001", "mod-002"],
          "execution_order": 3,
          "phases": [...]
        }
      ]
    },
    "flow_info": {
      "execution_order": ["mod-001", "mod-002", "mod-003", "mod-004"],
      "dependency_graph": {
        "mod-001": [],
        "mod-002": [],
        "mod-003": ["mod-001", "mod-002"],
        "mod-004": ["mod-003"]
      },
      "critical_path": ["mod-001", "mod-003", "mod-004"],
      "parallel_opportunities": [
        {
          "modules": ["mod-001", "mod-002"],
          "reason": "No dependencies between them"
        }
      ]
    },
    "statistics": {
      "total_modules": 4,
      "total_phases": 9,
      "total_leaf_tasks": 24,
      "depth_levels": 3
    }
  },
  "timestamp": "2026-01-12T12:00:00Z"
}
```

---

### 错误响应格式

```json
{
  "success": false,
  "error": {
    "code": "TASK_NOT_FOUND",
    "message": "Task with requirement_id 'req-999' not found",
    "details": {
      "requirement_id": "req-999"
    }
  },
  "timestamp": "2026-01-12T12:00:00Z"
}
```

### 错误码列表

| 错误码 | HTTP 状态码 | 说明 |
|--------|-------------|------|
| TASK_NOT_FOUND | 404 | 任务不存在 |
| INVALID_REQUIREMENT_ID | 400 | 无效的需求ID格式 |
| TASK_NOT_RUNNING | 400 | 任务未在运行中 |
| INTERNAL_ERROR | 500 | 服务器内部错误 |

---

## Skill 扩展系统

### 概述

支持用户导入自定义 Skill，系统自动将非规范文档转换为 Factory Skill 格式。任务执行时若 Skill 能力不足，自动暂停并提示用户导入所需 Skill。

### Skill 存储结构

```
.factory/
├── skills/                          # 系统内置 Skill
│   ├── task-planning.md
│   ├── task-execution.md
│   └── task-review.md
├── custom-skills/                   # 用户自定义 Skill
│   ├── registry.json                # Skill 注册表
│   ├── my-skill-1.md
│   └── my-skill-2.md
└── skill-templates/                 # Skill 模板
    └── skill-template.md
```

### registry.json 格式

```json
{
  "version": "1.0.0",
  "skills": [
    {
      "id": "skill-001",
      "name": "database-migration",
      "description": "数据库迁移技能",
      "file_path": "custom-skills/database-migration.md",
      "capabilities": ["sql", "migration", "schema-design"],
      "imported_at": "2026-01-12T10:00:00Z",
      "source": "user-import",
      "status": "active"
    }
  ]
}
```

### MCP 工具: Skill 管理

#### IMPORT_SKILL - 导入自定义技能

```typescript
IMPORT_SKILL: {
  input: {
    source: string,              // 文件路径或 URL
    name?: string,               // 可选，技能名称
    auto_convert?: boolean       // 默认 true，自动转换为规范格式
  },
  output: {
    success: true,
    skill_id: string,
    skill_name: string,
    converted: boolean,          // 是否经过格式转换
    original_format: string,     // 原始格式 (markdown/text/json)
    capabilities: string[],      // AI 识别的能力标签
    file_path: string,
    message: "Skill 导入成功，已添加到注册表"
  }
}
```

#### LIST_SKILLS - 列出已安装技能

```typescript
LIST_SKILLS: {
  input: {
    type?: "all" | "builtin" | "custom",  // 默认 all
    capability?: string                    // 按能力筛选
  },
  output: {
    success: true,
    skills: [
      {
        skill_id: string,
        name: string,
        type: "builtin" | "custom",
        capabilities: string[],
        status: "active" | "disabled",
        description: string
      }
    ],
    total: number
  }
}
```

#### VALIDATE_SKILL - 验证技能文档

```typescript
VALIDATE_SKILL: {
  input: {
    source: string               // 文件路径
  },
  output: {
    success: true,
    is_valid: boolean,
    format: "factory-standard" | "needs-conversion" | "invalid",
    issues: [
      {
        type: "error" | "warning",
        field: string,
        message: string
      }
    ],
    suggestion: string           // 修复建议
  }
}
```

### Skill 自动转换流程

```
用户文档 (任意格式)
        │
        ▼
┌─────────────────────┐
│  格式检测           │
│  - Markdown?        │
│  - 纯文本?          │
│  - JSON/YAML?       │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  AI 内容分析        │
│  - 提取技能名称     │
│  - 识别能力标签     │
│  - 解析使用说明     │
│  - 提取示例代码     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  生成规范 Skill     │
│  - Factory 格式     │
│  - 标准 frontmatter │
│  - 结构化内容       │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  注册到系统         │
│  - 更新 registry    │
│  - 保存文件         │
└─────────────────────┘
```

### 规范 Skill 模板

```markdown
---
name: skill-name
description: 技能描述
capabilities:
  - capability-1
  - capability-2
triggers:
  - "关键词1"
  - "关键词2"
version: "1.0.0"
---

# Skill 名称

## 概述
技能的详细描述...

## 使用场景
- 场景1
- 场景2

## 指令
当触发此技能时，执行以下操作...

## 示例
\`\`\`
示例代码或用法
\`\`\`
```

---

## Skill 失败处理机制

### 失败检测与自动暂停

任务执行时，系统监控 Skill 执行状态。当检测到能力不足时，自动暂停任务并输出详细错误信息。

### 失败状态结构

```json
{
  "requirement_id": "req-001",
  "task_id": "leaf-003",
  "status": "paused_skill_failure",
  "failure_info": {
    "failed_at": "2026-01-12T11:30:00Z",
    "skill_attempted": "database-migration",
    "error_type": "SKILL_NOT_FOUND",
    "error_message": "未找到数据库迁移相关技能",
    "context": {
      "task_name": "创建用户表迁移",
      "required_capabilities": ["sql", "migration", "postgresql"],
      "available_capabilities": ["sql", "mysql"],
      "missing_capabilities": ["migration", "postgresql"]
    },
    "suggestion": {
      "action": "导入具有 postgresql 迁移能力的 Skill",
      "example_command": "IMPORT_SKILL(source='path/to/postgresql-migration.md')",
      "alternative": "或手动完成此任务后调用 RESUME_TASK"
    }
  }
}
```

### 错误类型

| 错误类型 | 说明 | 处理建议 |
|----------|------|----------|
| SKILL_NOT_FOUND | 未找到匹配的 Skill | 导入相关 Skill |
| SKILL_CAPABILITY_INSUFFICIENT | Skill 能力不足 | 导入更强的 Skill 或升级现有 Skill |
| SKILL_EXECUTION_ERROR | Skill 执行出错 | 检查 Skill 定义或手动处理 |
| SKILL_TIMEOUT | Skill 执行超时 | 拆分任务或优化 Skill |

### 恢复流程

```
任务执行中
    │
    ▼
┌─────────────────┐
│ Skill 执行失败  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 自动暂停任务    │
│ 保存状态机      │
│ 输出错误详情    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 用户操作        │
│ 1. 导入 Skill   │
│ 2. 手动处理     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ RESUME_TASK     │
│ 继续执行        │
└─────────────────┘
```

### 使用示例

```bash
# 1. 任务执行中遇到 Skill 失败，系统自动暂停
# 输出:
# {
#   "status": "paused_skill_failure",
#   "error_message": "未找到 PostgreSQL 迁移技能",
#   "missing_capabilities": ["postgresql", "migration"],
#   "suggestion": "IMPORT_SKILL(source='postgresql-migration.md')"
# }

# 2. 用户导入所需 Skill
IMPORT_SKILL(source="D:/skills/postgresql-migration.md")
# 返回: { success: true, skill_id: "skill-002", capabilities: ["postgresql", "migration"] }

# 3. 继续执行任务
RESUME_TASK(requirement_id="req-001")
# 返回: { success: true, message: "任务已恢复，从 leaf-003 继续执行" }
```

---

## 系统可维护性设计

### 设计原则

| 原则 | 说明 |
|------|------|
| 文档即配置 | 通过修改本文档即可扩展系统功能 |
| 模块化架构 | 各组件独立，可单独升级替换 |
| 向后兼容 | 新功能不破坏现有接口 |
| 错误隔离 | 单个模块失败不影响整体系统 |

### 功能扩展方式

#### 1. 通过文档扩展 (推荐)

打开本文档，在对应章节添加新功能定义：

```markdown
## 新功能名称

### 概述
功能描述...

### MCP 工具定义
\`\`\`typescript
NEW_COMMAND: {
  input: { ... },
  output: { ... }
}
\`\`\`

### 实现说明
...
```

系统读取文档后自动识别新功能并提示实现。

#### 2. 通过 Skill 扩展

导入新的 Skill 文件，无需修改核心代码：

```bash
IMPORT_SKILL(source="new-feature-skill.md")
```

#### 3. 通过配置扩展

修改 `.factory/config.json`:

```json
{
  "extensions": {
    "custom-module": {
      "enabled": true,
      "config": { ... }
    }
  }
}
```

### 版本管理

```json
{
  "system_version": "1.0.0",
  "spec_version": "2026-01-12",
  "changelog": [
    {
      "version": "1.0.0",
      "date": "2026-01-12",
      "changes": [
        "初始版本",
        "支持任务状态机",
        "支持 Skill 扩展"
      ]
    }
  ]
}
```

---

## 系统稳定性保障

### 错误处理策略

```typescript
/**
 * 全局错误处理器
 * 
 * @description 捕获所有未处理异常，确保系统不崩溃
 * @related TaskStateMachine - 状态机恢复
 * @related BackupService - 数据备份
 */
class GlobalErrorHandler {
  /**
   * 处理错误，返回安全结果
   */
  handle(error: Error, context: ExecutionContext): SafeResult {
    // 1. 记录错误日志
    console.error(`[${context.module}] Error: ${error.message}`);
    console.error(`[${context.module}] Stack: ${error.stack}`);
    
    // 2. 保存当前状态
    this.stateService.saveEmergencyState(context);
    
    // 3. 返回安全结果，不抛出异常
    return {
      success: false,
      error: error.message,
      errorCode: this.classifyError(error),
      recoverable: true,
      suggestion: this.getSuggestion(error)
    };
  }
}
```

### 状态保护机制

```
┌─────────────────────────────────────────────────────────────┐
│                     状态保护层                               │
├─────────────────────────────────────────────────────────────┤
│  1. 操作前快照    - 每次状态变更前保存快照                    │
│  2. 事务性更新    - 状态更新要么全部成功，要么全部回滚         │
│  3. 定期备份      - 每 5 分钟自动备份状态机                   │
│  4. 崩溃恢复      - 启动时检测未完成任务，自动恢复             │
└─────────────────────────────────────────────────────────────┘
```

### 健康检查

```typescript
// GET /api/v1/health
{
  "status": "healthy",
  "components": {
    "mcp_server": "ok",
    "state_store": "ok",
    "skill_registry": "ok",
    "backup_service": "ok"
  },
  "uptime": "2h 30m",
  "last_error": null,
  "active_tasks": 2
}
```

### 日志规范

```typescript
// 日志级别和格式
[2026-01-12T12:00:00Z] [INFO]  [TaskService] Task created: req-001
[2026-01-12T12:00:01Z] [DEBUG] [Scheduler] Scheduling phase-001, 3 leaf tasks
[2026-01-12T12:00:02Z] [WARN]  [SkillService] Skill not found: postgresql-migration
[2026-01-12T12:00:03Z] [ERROR] [TaskService] Task execution failed: leaf-003
                               Error: SKILL_NOT_FOUND
                               Context: { task: "创建用户表", required: ["postgresql"] }
                               Action: Task paused, waiting for skill import
```

---

## MCP 安装与使用

### 安装配置

在 `~/.factory/mcp.json` 中添加：

```json
{
  "mcpServers": {
    "oh-my-task": {
      "type": "stdio",
      "command": "node",
      "args": ["D:/Project/AIProject/AIAgent/oh-my-task-mcp/dist/index.js"]
    }
  }
}
```

MCP 服务器启动时会自动使用 `process.cwd()` 获取当前工作目录。

### 自动初始化

MCP 服务器启动时会自动在当前项目目录下创建文档结构：

```
{当前项目}/docs/
├── requirements/           # 需求文档
├── development/            # 开发文档
├── testing/                # 测试文档
├── backup/                 # 备份
└── task-state/             # 状态机
    └── running-tasks.json
```

### 命令使用方法

MCP 工具调用格式: `oh-my-task___<命令名>`

参数通过 JSON 对象传递：

| 命令 | 参数示例 |
|------|----------|
| `oh-my-task___TASK_HELP` | `{}` |
| `oh-my-task___CREATE_TASK` | `{"title": "项目名", "description": "描述", "task_depth": 3}` |
| `oh-my-task___APPROVE_REQUIREMENT` | `{"requirement_id": "t1", "approved": true}` |
| `oh-my-task___SET_HUMANTEST` | `{"requirement_id": "t1", "enabled": true}` |
| `oh-my-task___START_TASK` | `{"requirement_id": "t1", "parallel_count": 2}` |
| `oh-my-task___COMPLETE_LEAF` | `{"requirement_id": "t1", "leaf_id": "leaf-xxx"}` |
| `oh-my-task___GET_EXECUTABLE_TASKS` | `{"requirement_id": "t1"}` |
| `oh-my-task___PAUSE_TASK` | `{"requirement_id": "t1"}` |
| `oh-my-task___RESUME_TASK` | `{"requirement_id": "t1"}` |
| `oh-my-task___FINISH_TASK` | `{"requirement_id": "t1"}` 或 `{"requirement_id": "t1", "force": true}` |
| `oh-my-task___DELETE_TASK` | `{"requirement_id": "t1"}` |
| `oh-my-task___LIST_TASKS` | `{}` 或 `{"status": "running"}` |
| `oh-my-task___LIST_RUNNING_TASKS` | `{}` |
| `oh-my-task___GET_TASK_CONTEXT` | `{"requirement_id": "t1"}` |
| `oh-my-task___GET_TASK_OVERVIEW` | `{"requirement_id": "t1"}` |

### 使用流程示例

```
1. 查看帮助
   oh-my-task___TASK_HELP

2. 创建任务
   oh-my-task___CREATE_TASK
   参数: {"title": "电商系统", "description": "开发电商平台", "task_depth": 3}
   返回: {
     "success": true,
     "data": {"id": "t1", ...},
     "message": "任务创建成功。任务ID: t1\n\n已生成需求文档: docs/requirements/t1-requirement.md\n\n【重要】请停止执行，等待用户审批！"
   }

3. 审批需求
   oh-my-task___APPROVE_REQUIREMENT
   参数: {"requirement_id": "t1", "approved": true}

4. 开始执行
   oh-my-task___START_TASK
   参数: {"requirement_id": "t1"}

5. 暂停任务 (保留代码)
   oh-my-task___PAUSE_TASK
   参数: {"requirement_id": "t1"}

6. 继续任务
   oh-my-task___RESUME_TASK
   参数: {"requirement_id": "t1"}

7. 强制停止 (删除未完成代码)
   oh-my-task___FINISH_TASK
   参数: {"requirement_id": "t1", "force": true}

8. 删除任务
   oh-my-task___DELETE_TASK
   参数: {"requirement_id": "t1"}
```

---

## Factory Hooks 集成

### 概述

使用 Factory Hooks 确保关键流程不被打断，提供确定性控制。

Hooks 在 Droid 生命周期的不同阶段执行用户定义的命令，将建议转换为每次都会执行的应用级代码。

### Hook 事件类型

| 事件 | 触发时机 | 用途 |
|------|----------|------|
| PreToolUse | 工具调用前 | 可阻止工具执行 |
| PostToolUse | 工具调用后 | 自动格式化、日志记录 |
| UserPromptSubmit | 用户提交提示时 | 预处理用户输入 |
| Notification | 发送通知时 | 自定义通知方式 |
| Stop | Droid 完成响应时 | 清理、状态保存 |
| SubagentStop | 子代理任务完成时 | 任务状态更新 |
| SessionStart | 会话开始时 | 初始化、恢复状态 |
| SessionEnd | 会话结束时 | 保存状态、备份 |

### oh-my-task 推荐 Hooks 配置

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"$FACTORY_PROJECT_DIR\"/.factory/hooks/task-restore.js"
          }
        ]
      }
    ],
    "SubagentStop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"$FACTORY_PROJECT_DIR\"/.factory/hooks/task-status-update.js"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"$FACTORY_PROJECT_DIR\"/.factory/hooks/task-state-save.js"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write|Create",
        "hooks": [
          {
            "type": "command",
            "command": "node \"$FACTORY_PROJECT_DIR\"/.factory/hooks/doc-sync.js"
          }
        ]
      }
    ]
  }
}
```

### Hook 脚本说明

#### 1. task-restore.js (SessionStart)

会话开始时自动恢复未完成的任务状态：

```javascript
// .factory/hooks/task-restore.js
const fs = require('fs');
const path = require('path');

const stateFile = path.join(process.env.FACTORY_PROJECT_DIR, 'docs/task-state/running-tasks.json');

if (fs.existsSync(stateFile)) {
  const state = JSON.parse(fs.readFileSync(stateFile, 'utf8'));
  const pausedTasks = state.tasks.filter(t => t.status === 'paused' || t.status === 'running');
  
  if (pausedTasks.length > 0) {
    console.log(`[oh-my-task] 检测到 ${pausedTasks.length} 个未完成任务:`);
    pausedTasks.forEach(t => {
      console.log(`  - ${t.requirement_id}: ${t.task_name} (${t.status})`);
    });
    console.log('[oh-my-task] 使用 RESUME_TASK 继续执行');
  }
}
```

#### 2. task-status-update.js (SubagentStop)

子代理完成时自动更新任务状态：

```javascript
// .factory/hooks/task-status-update.js
const fs = require('fs');
const input = JSON.parse(fs.readFileSync('/dev/stdin', 'utf8'));

// 解析子代理完成信息，更新任务状态
const taskId = input.subagent_context?.task_id;
if (taskId) {
  console.log(`[oh-my-task] 子任务完成: ${taskId}`);
  // 触发状态机更新...
}
```

#### 3. task-state-save.js (Stop)

Droid 停止时自动保存状态机：

```javascript
// .factory/hooks/task-state-save.js
const fs = require('fs');
const path = require('path');

const stateDir = path.join(process.env.FACTORY_PROJECT_DIR, 'docs/task-state');
const stateFile = path.join(stateDir, 'running-tasks.json');

if (fs.existsSync(stateFile)) {
  const state = JSON.parse(fs.readFileSync(stateFile, 'utf8'));
  state.last_saved = new Date().toISOString();
  fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));
  console.log('[oh-my-task] 状态机已保存');
}
```

#### 4. doc-sync.js (PostToolUse)

文件编辑后自动同步文档：

```javascript
// .factory/hooks/doc-sync.js
const fs = require('fs');
const input = JSON.parse(fs.readFileSync('/dev/stdin', 'utf8'));

const filePath = input.tool_input?.file_path || '';

// 如果修改了代码文件，检查是否需要更新对应文档
if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
  console.log(`[oh-my-task] 代码变更: ${filePath}`);
  // 提醒更新文档...
}
```

### 关键流程保护

| 流程 | Hook | 保护措施 |
|------|------|----------|
| 任务状态恢复 | SessionStart | 自动检测并提示恢复 |
| 子任务完成 | SubagentStop | 自动更新状态机 |
| 会话结束 | Stop | 自动保存状态 |
| 文档同步 | PostToolUse | 代码变更后提醒更新文档 |

### 配置位置

- **项目级**: `.factory/settings.json` (仅当前项目)
- **用户级**: `~/.factory/settings.json` (所有项目)

### 备份与恢复机制

任务开始时自动创建备份，用于强制停止时恢复：

```
docs/
├── backup/                          # 备份文件夹 (任务完成后自动删除)
│   └── {requirement_id}/            # 按需求ID分组
│       ├── development/             # 开发文档备份 (开发前状态)
│       ├── code/                    # 代码备份 (开发前状态)
│       └── state.json               # 状态机快照
```

### 状态机记录文件

```
docs/task-state/
├── running-tasks.json               # 所有运行中的任务状态机
└── {requirement_id}/
    └── state.json                   # 单个任务的状态机详情
```

**running-tasks.json 格式:**
```json
{
  "tasks": [
    {
      "requirement_id": "req-001",
      "task_name": "电商系统开发",
      "status": "running",
      "current_module": "用户模块",
      "current_phase": "认证阶段",
      "current_task": "登录功能",
      "started_at": "2026-01-12T09:00:00Z",
      "last_updated": "2026-01-12T11:30:00Z"
    }
  ]
}
```

**state.json 格式 (单个任务状态机):**
```json
{
  "requirement_id": "req-001",
  "task_name": "电商系统开发",
  "status": "running",
  "created_at": "2026-01-12T09:00:00Z",
  "execution_state": {
    "current_module_index": 1,
    "current_module_name": "用户模块",
    "module_status": "in_progress",
    "current_phase_index": 0,
    "current_phase_name": "认证阶段",
    "current_task_index": 2,
    "current_task_name": "密码重置",
    "task_status": "in_progress"
  },
  "completed_modules": ["商品模块"],
  "completed_phases": {
    "用户模块": []
  },
  "completed_tasks": {
    "用户模块/认证阶段": ["登录功能", "注册功能"]
  },
  "backup_path": "docs/backup/req-001/"
}
```

### MCP 工具详细定义

#### CREATE_TASK - 创建任务

```typescript
CREATE_TASK: {
  input: {
    title: string,
    description: string,
    task_depth?: number  // 默认 3
  },
  output: {
    requirement_id: string,      // 需求ID，用于暂停/继续/停止
    task_id: string,
    requirement_doc_path: string,
    backup_path: string,         // 备份路径
    status: 'PENDING_APPROVAL'
  }
}
```

#### FINISH_TASK - 结束/强制停止任务

**行为说明：**
- `force=false`：正常结束任务，保留所有代码和文档
- `force=true`：强制关闭状态机，删除当前未完成模块的代码，恢复该模块的开发文档到开发前状态
- 无论 `force` 值如何，都可以通过 `RESUME_TASK` 继续任务

**与 PAUSE_TASK 的区别：**
- `PAUSE_TASK`：暂停任务，保留所有代码和进度，状态机保持 `paused`
- `FINISH_TASK(force=true)`：强制停止，删除未完成模块代码，恢复文档，状态机变为 `force_stopped`

```typescript
FINISH_TASK: {
  input: {
    requirement_id: string,      // 需求ID
    force?: boolean,             // true=强制停止（删除代码、恢复文档）
    module_id?: string           // 可选，指定停止的模块
  },
  output: {
    // force=false (正常结束) - 任务完成，保留所有内容
    success: true,
    task_id: string,
    status: "completed",
    test_results: TestResults,
    completion_status: CompletionStatus,
    message: "任务已完成"
    
    // force=true, module_id=undefined (强制停止整个任务)
    success: true,
    action: "force_stop_all",
    status: "force_stopped",     // 可通过 RESUME_TASK 继续
    affected_modules: [
      {
        module_id: string,
        module_name: string,
        deleted_code: string[],      // 删除的代码文件
        restored_docs: string[]      // 恢复的文档文件
      }
    ],
    message: "任务已强制停止，未完成模块的代码已删除，文档已恢复。可通过 RESUME_TASK 继续"
    
    // force=true, module_id="mod-001" (强制停止指定模块)
    success: true,
    action: "force_stop_module",
    status: "force_stopped",
    module_id: string,
    module_name: string,
    deleted_code: string[],          // 删除的代码文件
    restored_docs: string[],         // 恢复的文档文件
    message: "模块已强制停止，代码已删除，文档已恢复。可通过 RESUME_TASK 继续"
  }
}
```

**force=true 执行流程：**
```
FINISH_TASK(force=true)
        │
        ▼
┌─────────────────────────────────────┐
│ 1. 识别未完成的模块                  │
│    - 状态为 running/in_progress     │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. 删除未完成模块的代码              │
│    - 根据 backup 中的文件列表       │
│    - 删除开发过程中新增的代码文件    │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. 恢复开发文档                      │
│    - 从 backup 恢复 development/    │
│    - 文档回到开发前状态              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. 更新状态机                        │
│    - status = "force_stopped"       │
│    - 保留任务结构和已完成模块        │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 5. 保留 backup (用于 RESUME)        │
│    - 不删除 backup 文件夹           │
│    - RESUME_TASK 时可重新开始       │
└─────────────────────────────────────┘
```

#### PAUSE_TASK - 暂停任务

```typescript
PAUSE_TASK: {
  input: {
    requirement_id: string       // 需求ID
  },
  output: {
    success: true,
    requirement_id: string,
    paused_at: string,
    state_saved_to: string,      // 状态机保存路径
    execution_state: {
      current_module: string,
      current_phase: string,
      current_task: string,
      progress_percent: number
    },
    message: "任务已暂停，可通过 RESUME_TASK 继续执行"
  }
}
```

#### RESUME_TASK - 继续任务

```typescript
RESUME_TASK: {
  input: {
    requirement_id: string       // 需求ID
  },
  output: {
    success: true,
    requirement_id: string,
    resumed_at: string,
    execution_state: {
      current_module: string,
      current_phase: string,
      current_task: string,
      next_action: string        // 下一步要执行的操作
    },
    message: "任务已恢复，从 {current_task} 继续执行"
  }
}
```

#### LIST_RUNNING_TASKS - 列出运行中的任务

```typescript
LIST_RUNNING_TASKS: {
  input: {},
  output: {
    success: true,
    tasks: [
      {
        requirement_id: string,
        task_name: string,
        status: "running" | "paused",
        current_module: string,
        current_task: string,
        progress_percent: number,
        started_at: string,
        last_updated: string
      }
    ],
    total_running: number,
    total_paused: number
  }
}
```

#### LIST_TASKS - 列出所有任务 (含模块ID)

```typescript
LIST_TASKS: {
  input: {
    requirement_id?: string,     // 可选，筛选特定需求
    status?: string              // 可选，筛选状态
  },
  output: {
    success: true,
    tasks: [
      {
        task_id: string,
        module_id: string,       // 模块ID (用于 FINISH_TASK)
        module_name: string,
        task_name: string,
        status: string,
        test_status: string
      }
    ]
  }
}
```

### 任务控制流程图

```
                    ┌──────────────┐
                    │ CREATE_TASK  │
                    │ 返回需求ID    │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │   执行中      │◄─────────────────┐
                    │  (running)   │                  │
                    └──────┬───────┘                  │
                           │                         │
           ┌───────────────┼───────────────┐         │
           │               │               │         │
           ▼               ▼               ▼         │
    ┌────────────┐  ┌────────────┐  ┌────────────┐   │
    │ PAUSE_TASK │  │FINISH_TASK │  │FINISH_TASK │   │
    │  (暂停)    │  │  (正常)    │  │  (强制)    │   │
    └─────┬──────┘  └─────┬──────┘  └─────┬──────┘   │
          │               │               │          │
          ▼               ▼               ▼          │
    ┌────────────┐  ┌────────────┐  ┌────────────┐   │
    │  paused    │  │ completed  │  │  stopped   │   │
    │ 保存状态机  │  │ 返回测试   │  │ 恢复备份   │   │
    │            │  │ 完成情况   │  │ 删除代码   │   │
    └─────┬──────┘  └────────────┘  └────────────┘   │
          │                                          │
          │ RESUME_TASK                              │
          └──────────────────────────────────────────┘
```

### 使用示例

```bash
# 1. 创建任务，获取需求ID
CREATE_TASK(title="电商系统", description="...", task_depth=3)
# 返回: { requirement_id: "req-001", ... }

# 2. 查看所有运行中的任务
LIST_RUNNING_TASKS()
# 返回: { tasks: [{ requirement_id: "req-001", status: "running", ... }] }

# 3. 暂停任务
PAUSE_TASK(requirement_id="req-001")
# 返回: { success: true, state_saved_to: "docs/task-state/req-001/state.json" }

# 4. 继续任务
RESUME_TASK(requirement_id="req-001")
# 返回: { success: true, next_action: "继续执行 密码重置 任务" }

# 5. 查看任务列表 (获取模块ID)
LIST_TASKS(requirement_id="req-001")
# 返回: { tasks: [{ module_id: "mod-001", module_name: "用户模块", ... }] }

# 6. 强制停止指定模块
FINISH_TASK(requirement_id="req-001", force=true, module_id="mod-001")
# 返回: { action: "force_stop_module", restored_files: [...], deleted_code: [...] }

# 7. 强制停止整个任务
FINISH_TASK(requirement_id="req-001", force=true)
# 返回: { action: "force_stop_all", restored_files: [...], deleted_code: [...] }
```
