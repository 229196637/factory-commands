---
name: lua-deep-reader
description: 深度阅读Lua代码，追踪变量、函数的依赖关系和调用链。当遇到底层API（base._xxx）或服务器交互协议时自动停止。用于代码分析、功能理解、架构梳理。
---

# Lua 深度代码阅读

深度阅读Lua代码，了解代码、变量、函数的依赖关系，阅读到无法再阅读的底层API或服务器交互的地方就停止。

## 触发场景

- 用户说"阅读代码"、"分析代码"、"理解代码"
- 用户说"追踪调用链"、"依赖关系"
- 用户说"这个函数是干什么的"、"这个变量从哪来"
- 用户说"深度阅读"、"代码分析"

---

## Phase 1: 入口定位

### 1.1 确定起点

根据用户输入确定阅读起点：

| 输入类型 | 处理方式 |
|---------|---------|
| 文件路径 | 直接读取该文件 |
| 函数名 | 使用 Grep 搜索函数定义 |
| 类名 | 搜索 `class("ClassName"` 或 `ClassName = class` |
| 错误堆栈 | 从堆栈顶部开始追踪 |
| 日志输出 | 搜索日志中的函数名/文件名 |

### 1.2 搜索策略

```lua
-- 搜索函数定义
Grep: "function ClassName.FunctionName" 或 "function ClassName:FunctionName"

-- 搜索类定义
Grep: "class(\"ClassName\"" 或 "ClassName = class"

-- 搜索变量使用
Grep: "self.m_VariableName" 或 "g_VariableName"
```

---

## Phase 2: 递归追踪

### 2.1 向上追踪（谁调用了这个函数）

1. 使用 Grep 搜索函数被调用的位置
2. 记录调用者的文件和行号
3. 继续追踪调用者的调用者（递归）

```
搜索模式:
- ClassName:FunctionName(
- ClassName.FunctionName(
- self:FunctionName(
- g_CtrlName:FunctionName(
```

### 2.2 向下追踪（这个函数调用了谁）

1. 阅读函数体内容
2. 识别所有函数调用
3. 对每个调用进行递归追踪

### 2.3 数据流追踪

追踪变量的来源和去向：

```
变量来源:
- 函数参数
- self.m_xxx 成员变量
- g_xxx 全局变量
- local 局部变量
- 函数返回值
```

### 2.4 记录依赖关系

使用树形结构记录：

```
FunctionA (file:line)
  ├─> FunctionB (file:line)
  │     ├─> FunctionC (file:line)
  │     └─> [边界] base._xxx
  └─> FunctionD (file:line)
        └─> [边界] GS2CXxx
```

---

## Phase 3: 边界识别（停止条件）

### 3.1 停止边界定义

| 边界类型 | 识别模式 | 说明 |
|---------|---------|------|
| 星火底层API | `base._xxx` | 星火编辑器内部实现，无法追踪 |
| 引擎API | `UnityEngine.*` | Unity/星火引擎封装 |
| 服务器协议 | `GS2C*`, `C2GS*` | 客户端-服务器边界 |
| 类型系统 | `classtype.*` | 底层类型定义 |
| 全局控制器 | `g_*Ctrl` | 如果已分析过则停止 |

### 3.2 边界处理

遇到边界时：
1. 标记为边界节点
2. 记录边界类型
3. 停止该分支的追踪
4. 继续其他分支

### 3.3 常见边界API参考

**星火底层API (base._xxx)**:
- `base._unit_set_attr` - 设置单位属性
- `base._unit_get_attr` - 获取单位属性
- `base._create_unit` - 创建单位
- `base._destroy_unit` - 销毁单位
- `base.gui_new` - 创建UI
- `base.gui_check` - 检查UI

**服务器协议**:
- `GS2C*` - 服务器到客户端消息
- `C2GS*` - 客户端到服务器消息
- `netwar.*` - 战斗网络协议
- `netlogin.*` - 登录网络协议

**引擎API**:
- `UnityEngine.GameObject.*`
- `UnityEngine.Transform.*`
- `classtype.MeshRender`
- `classtype.SceTransform`

---

## Phase 4: 输出报告

### 4.1 报告模板

```markdown
## 代码阅读报告

### 1. 入口点
- **文件**: [文件路径]
- **函数**: [函数名]
- **目的**: [用户的分析目标]

### 2. 调用关系图

```
[入口函数] (file:line)
  ├─> [被调用函数1] (file:line)
  │     └─> [边界API] ← 停止
  └─> [被调用函数2] (file:line)
        └─> [边界API] ← 停止
```

### 3. 数据流向

| 变量 | 来源 | 处理 | 使用 |
|-----|------|------|------|
| xxx | 参数/成员 | 函数处理 | 传递给xxx |

### 4. 边界API列表

| API | 类型 | 说明 |
|-----|------|------|
| base._xxx | 星火底层 | [功能说明] |
| GS2CXxx | 服务器协议 | [功能说明] |

### 5. 关键发现

- [重要逻辑说明]
- [潜在问题]
- [架构特点]
```

---

## 追踪深度控制

### 默认深度
- 向下追踪：最多 5 层
- 向上追踪：最多 3 层

### 深度调整
用户可以指定：
- "深度阅读到底" - 追踪到所有边界
- "只看一层" - 只追踪直接调用
- "追踪 N 层" - 指定深度

---

## 常见追踪模式

### 模式1: 功能理解
```
目标: 理解某个功能的实现
起点: 功能入口函数
方向: 向下追踪
输出: 调用关系图 + 关键逻辑说明
```

### 模式2: Bug定位
```
目标: 从错误堆栈定位问题
起点: 错误发生点
方向: 向上追踪调用者 + 向下追踪数据来源
输出: 调用链 + 数据流 + 问题点
```

### 模式3: 架构梳理
```
目标: 理解模块间关系
起点: 模块入口/控制器
方向: 广度优先追踪
输出: 模块依赖图 + 接口说明
```

---

## 与其他技能的配合

```
代码理解 → [lua-deep-reader] 深度阅读
    ↓
发现问题 → [legacy-code-bug-fixer] 修复Bug
    ↓
需要调试 → [debug-info-adder] 添加调试信息
    ↓
查API → [sce-api-reference] 查阅文档
```

---

## 注意事项

1. **避免循环追踪**: 记录已追踪的函数，避免重复
2. **控制输出量**: 大型调用链只展示关键路径
3. **标注不确定性**: 对于推测的逻辑，明确标注
4. **保持聚焦**: 围绕用户的分析目标，不要发散
5. **及时停止**: 遇到边界立即停止，不要尝试猜测底层实现
